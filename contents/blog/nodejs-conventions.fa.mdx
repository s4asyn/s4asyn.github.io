---
title: 'قراردادهایی در برنامه نویسی وب در محیط Node.JS'
date: '2020-05-02'
lang: 'fa'
type: 'blog'
published: 'no'
desc: 'قراردادهایی در تمیزتر کد زدن به زبان JavaScript در سمت سرور'
tags: ['web', 'js', 'nodejs']
---

یکی از گلایه‌های بسیاری از برنامه‌نویسانی که شروع به کار با زبان جاوااسکریپت می‌کنند، نبود قراردادهای برنامه‌نویسی و انعطاف بسیار زیاد این زبان است. این گلایه با بزرگ شدن برنامه و تیم‌های توسعه‌ی آن افزایش می‌یابد و بنظر در برنامه‌نویسی سمت سرور با این زبان به اوج خود می رسد. برای رفع این راهکارهای مختلفی ارائه شده است. برخی از سازمانها نظیر Google و Airbnb اقدام به انتشار قراردادهای سامانی خود برای توسعه با زبان جاوااسکریپت کرده اند. برخی دیگر نیز با ارائه‌ی زبانهایی نظیر TypeScript تلاش کرده اند تا با کاهش تفسیرهای این زبان در مسیر افزایش کیفیت برنامه های توسعه یافته حرکت کرده‌اند. البته به دلیل استاندارد و همگانی نبودن این رویکردها، بی‌نظمی در سطح زبان به تنوع بسیار زیاد در سطح قراردادها تبدیل شده است.

در این مستند مجموعه‌ای از قراردادها (Conventions) و به‌روشها (Best Practice) که در مسیر برنامه‌نویسی سمت سرور به نظرم مفید بودند را مکتوب خواهم کرد تا مرجعی برای استفاده‌ی آینده‌ی خودم یا دیگران باشد. البته لازم به یادآوری است که در این موارد بیشتر از اینکه قانون باشند، قرارداد هستند. به عبارت دیگر در اکثر این موارد پیروی یا عدم پیروی از این قوانین معادل درست یا غلط بودن نیست و صرفاً از روی تجربه به دست آمده‌اند.

## سبک کدنویسی (Coding Style)

اولین سطح برخود به طور قطع خود زبان جاوااسکریپت است. در توسعه‌ی این زبان اگرچه همچون دیگر زبانهای برنامه نویسی در صورت نقض syntax اعلام خطا می کند، اما بنظر با توجه به خواستگاه اولیه‌ی این زبان، همانند زبانهای نشانه‌گذاری HTML و CSS که به صورت دست بالا پردازش [(Permissive code)](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Debugging_HTML) می‌شوند، اولویت اصلی را اجرا برنامه و بروز حداقل خطا برای رسیدن محتوی به دست مخاطب قرار داده است و در نتیجه در برخی موارد بجای وضع قوانین syntax محدود کننده‌ی عدم قطعیت برنامه، قوانین تفسیری از شرایط مختلف را در اولویت قرار داده است، که از نمونه‌های آن می‌توان به قوانین جایگزاری «;» و تبدیل تایپ اشاره کرد.

مواردی که در این بخش بررسی می‌شوند با محدود کردن توسعه‌دهندگان به قوانینی بیشتر از قوانین زبان جاوااسکریپت تلاش می‌کنند تا آنجایی که ممکن است جلوی بروز مشکلات منطقی و عملکردی را بگیرند.

### ابزارها

ابزارهای بسیار زیادی در این حوزه وجود دارند که در ادامه سه ابزاری که ترکیبشان بهترین کارایی را برای من داشته است شرح می‌دهم.

#### ‌Babel: ابزار Transcompiler

اولین نسخه‌ی استاندارد زبان جاوااسکریپت در سال ۱۹۹۷ با عنوان ECMAScript منتشر شد و از سال ۲۰۱۵ هر سال نسخه‌ی بروزشده‌ی این استاندارد منتشر می‌شود. اما بسیاری از مفسرهای این زبان از نسخه‌های جدید این استاندارد و قابلیت‌های آن پشتیبانی نمی‌کنند. به همین دلیل ابزارهایی نظیر [Babel](https://babeljs.io/) وظیفه‌ی ترجمه‌ی نسخه‌های جدید به نسخه‌های قدیمی را بر عهده دارند. به این ترتیب توسعه‌دهندگان از قابلیت‌های نسخه‌های جدید بدون نگرانی از عمل نکردن آن در محیط‌های مختلف استفاده می‌کنند.

مجموعه ابزارهایی که من در این حوزه در پروژه‌های مختلف استفاده می‌کنم با استفاده از دستور زیر قابل نصب هستند.

```bash
npm i -D @babel/cli @babel/core @babel/node\
         @babel/plugin-transform-runtime \
         @babel/preset-env babel-eslint \
         babel-plugin-module-resolver

npm i @babel/runtime
```

همچنین برای این ابزار به طور معمول از پیکربندی زیر استفاده می‌کنم. این پیکربندی باید در فایل `bash>.babelrc.js` قرار داده شود.

```js
module.exports = {
    presets: [
        [
            '@babel/preset-env',
            {
                targets: {
                    node: 'current',
                },
            },
        ],
    ],
    plugins: [
        '@babel/plugin-transform-runtime',
        [
            require.resolve('babel-plugin-module-resolver'),
            {
                root: ['./'],
                alias: {
                    '#root': './src/',
                    '#config': './src/config/',
                    '#api': './src/api/',
                    '#services': './src/services/',
                },
            },
        ],
    ],
};
```

همچنین خطوط زیر به فایل `bash>package.json` اضافه می‌شود.

```json
    "scripts": {
        "dev": "nodemon ./src/server --exec babel-node",
        "start": "npm run build && npm run start:server",
        "build": "babel src -s -D -d build",
        "start:server": "node build/server"
    },
```

به طور خلاصه مجموعه‌ی این ابزارها و پیکربندی موارد زیر را اعمال می‌کند:

-   تنظیمات بهینه توسط preset-env برای نسخه‌ای از node که کار ترجمه بر روی آن انجام می‌شود، انجام می‌شود.
-   استفاده از پلاگین `bash>babel-plugin-module-resolver` این امکان را فراهم می‌آورد تا از در زمان کد‌نویسی بجای الگوهایی نظیر `js>import config from '../../../../../config'` از `js>import config from '#config'` استفاده شود.

#### Prettier: ابزار Formatter

مواردی مانند استفاده از TAB یا Space و یا محل استفاده از «}» در برنامه‌نویسی وجود دارند که انتخاب آنها بسیار به سلیقه و راحتی توسعه‌دهنده بستگی دارد. ولی وقتی در مورد کار گروهی و نگهداری صحبت می‌کنیم، بهتر است نقاط مشترک تیم را تبدیل به قاعده‌ای برای اعمال کرد.

برای نصب این ابزار می‌توان از دستور زیر استفاده کرد:

```bash
npm i -D prettier
```

پیکربندی مورد استفاده‌ی من به صورت زیر است که باید در فایل `bash>.prettierrc.js` قرار گیرد.

```js
module.exports = {
    endOfLine: 'lf',
    semi: true,
    singleQuote: true,
    tabWidth: 4,
    arrowParens: 'always',
    trailingComma: 'all',
};
```

به طور خلاصه مجموعه‌ی این ابزارها و پیکربندی موارد زیر را اعمال می‌کند:

-   برای انتهای خطوط از Line Feed یا lf که به طور معمول در سیستم‌عامل‌های غیر از ویندوز مرسوم است، استفاده می‌شود.
-   تمامی خطوط semicolon خواهد داشت
-   از Single Quote برای مشخص کردن رشته استفاده می‌شود.
-   اندازه tab برابر ۴ space در نظر گرفته می‌شود.
-   در مواردی امکانش وجود دارد در انتها از comma استفاده شود.

#### ESLint: ابزار Linter

یکی از راهکارهای کاهش چالشهای رویکرد بالا، محدود کردن سبک کدنویسی با استفاده از ابزارهای در اصطلاح [Linter](<https://en.wikipedia.org/wiki/Lint_(software)>) است. این ابزارها که در اغلب موارد با ابزارهای توسعه تجمیع و یا در مراحل ذخیره‌سازی و تست کد اجرا می‌شوند، به رعایت مجموعه‌ای از قواعد کدنویسی در سطح یک تیم کمک می‌کنند. به تجربه برای من ثابت شده است که قوانین سبک کدنویسی به صورت شفاهی در کار گروهی دوام نمی‌آورند و اگر در مراحل مختلف تست نشوند محکوم به فراموشی و نقض هستند. به همین دلیل یکی از اولین فعالیت‌ها در شروع پروژه تنظیم این ابزارها است.

ابزارهای linter مختلفی در این حوزه وجود دارد که برخی پر کاربردتر هستند. در این بین ابزار [ESLint](https://eslint.org/) یکی از پرطرفدارترین ابزارهای linter در این حوزه است (تعداد دریافت‌های روزانه از مخازن NPM به عنوان مبنا درنظر گرفته شده است). این طیف وسیعی از مشکلات متداول در زمینه‌ی کیفیت و سبک کدنویسی پوشش می‌دهد. از آنجایی که قابلیت پیکربندی و گسترش پذیری خود ابزار یکی از اهداف اولیه‌ی توسعه‌ی آن بود است، قوانین و بسته‌های بسیاری در زمینه‌های مختلف نظیر امنیت و کارایی برای آن توسعه یافته است.

مجموعه ابزارهایی که من به طور معمول در پروژه‌های مختلف استفاده می‌کنم، در قطعه کدهای زیر آورده شده است.

```bash
npm i -D eslint \
         eslint-config-airbnb eslint-plugin-security \
         eslint-config-prettier eslint-plugin-prettier \
         eslint-plugin-import eslint-import-resolver-babel-module
```

برای این مجموعه ابزار به طور معمول از پیکربندی زیر استفاده می‌کنم. این پیکربندی باید در فایل `bash>.eslintrc.js` قرارداده شود.

```js
module.exports = {
    env: {
        es6: true,
        node: true,
    },
    plugins: ['security', 'import', 'prettier'],
    extends: [
        'eslint:recommended',
        'plugin:security/recommended',
        'plugin:import/errors',
        'plugin:import/warnings',
        'airbnb-base',
        'prettier',
        'plugin:prettier/recommended',
    ],
    globals: {
        Atomics: 'readonly',
        SharedArrayBuffer: 'readonly',
    },
    parser: 'babel-eslint',
    parserOptions: {
        ecmaVersion: 2018,
        sourceType: 'module',
    },
    rules: {
        indent: [2, 4, { SwitchCase: 1 }],
        'prettier/prettier': 'error',
        'no-eval': 'error',
        'no-var': 'error',
        'no-implied-eval': 'error',
        strict: 'off',
    },
    settings: {
        'import/resolver': {
            'babel-module': {},
        },
    },
};
```

به طور خلاصه مجموعه‌ی این ابزارها و پیکربندی موارد زیر را اعمال می‌کند:

-   محیط اجرایی Node.JS در نظر گرفته می‌شود.
-   از پارسر babel استفاده می‌شود.
-   استاندارد ES2018 در نظر گرفته می‌شود.
-   مقادیر import چک می‌شود.
-   مقادیر import از قوانین `bash>babel-plugin-module-resolver` پیروی می‌کنند. (در بخش babel توضیح داده شده است)
-   الگوها و به‌روشهای پیشنهادی شرکت airbnb در نظر گرفته می‌شود.
-   مقدار indentation یا فاصله‌ی ابتدایی هر عبارت معادل ۴ space و برای عبارت case در switchها ۲ است.
-   قوانین فرمت ابزار prettier در نظر گرفته می‌شود. (در بخش بالا توضیح داده شده است)
-   نکات امنیتی که در بسته‌ی Security آورده شده است در نظر گرفته می‌شود.

## پیکربندی (Configuration)

در کنار قراردادهای سبک کدزنی بینه‌سازی محیط اجرا برای دستیابی به بهترین عملکرد و کارایی یکی از مراحل توسعه‌ی هر محصولی است. در ادامه‌ی این بخش به برخی از این بهینه‌سازی‌ها خواهیم پرداخت.

### بهینه سازی Garbage Collection برای حافظه!

از آنجایی که هدف هر Garbage Collection بر بهینه‌سازی مصرف حافظه است، به طور معمول انتظار بر این است که در محیط Node.JS هم بهینه‌سازی بر اساس حافظه‌ی موجود باشد ولی بنظر می‌آید که GC محیط Node.JS اندکی تنبل (lazy) است! به این معنی که یک آستانه‌ی ثابت (مستقل از حجم حافظه و حدود 1.5GB)برای فعال شدن دارد و در مواردی تا عبور نکردن از آن آستانه اقدام به جمع‌آوری فضای حافظه بی‌استفاده نمی‌کند.

شاید بهتر باشد این مکانیزم با توجه به منابع سیستم و شرایط اجرا تنظیم شود. برای نمونه با استفاده از دستور زیر می‌توان منابع حداکثر حافظه قدیمی مورد پذیرش را به 512MB و بازه‌های زمانی اجرای این مکانیزم را ۱۰۰ ثانیه تنظیم کرد:

```bash
node --optimize_for_size --max_old_space_size=512 --gc_interval=100 server.js
```

یکی از اسکربپهای خوبی که در این زمینه دیدم اسکریپت [heroku-node-settings.sh](https://github.com/damianmr/heroku-node-settings) است. برای همین در شرایطی که حجم رم محیط اجرا کمتر از 1.5GB باشد از دستور زیر استفاده می‌کنم.

```bash
#!/bin/bash

TOTAL_MEMORY=$(vmstat -s|grep 'total memory'|cut -d 'K' -f 1|tr -d ' '|awk '{printf "%d", $1 / 1000 }')

if [ ! "$WEB_MEMORY" = "" ]; then
  if [ $WEB_MEMORY -le 512 ]; then
    NODE_FLAGS="--max_semi_space_size=2 --max_old_space_size=256"
  elif [ $WEB_MEMORY -le 768 ]; then
    NODE_FLAGS="--max_semi_space_size=8 --max_old_space_size=512"
  elif [ $WEB_MEMORY -le 1024 ]; then
    NODE_FLAGS="--max_semi_space_size=16 --max_old_space_size=1024"
  fi
fi

echo "Starting app with command:"
echo " " node $NODE_FLAGS "$@"
node $NODE_FLAGS "$@"
```

### ذخیره‌ی نسخه‌ی دقیق وابستگی‌ها در NPM

ترکیب خط پایین در فایل `bash>.npmrc` در پوشه‌ی اصلی پروژه و در کنار `bash>package.json` باعث می‌شود که نسخه‌ی دقیق وابستگی‌ها حفظ شود.

```ini
save-exact = true
save-prefix = ""
```

### اضافه کردن engines به package.json

عادت خوبی است که حواسمان به استفاده از نسخه‌ی محیطی که کد بر روی آن اجرا می‌شود باشد. پیکربندی متغیر engines در فایل package.json جلوی ناهماهنگی در محیط اجرا در زمان اجرا را می‌گیرد.

```json
"engines": {
  "node": "12.13.x"
}
```

### استفاده از js به جای فایل‌های json پیکربندی

یکی از مشکلاتی که در استفاده از فایلهایی که با فرمت json با آن مواجه شدم، عدم امکان کامنت‌گذاری در این فایلها بود. علاوه بر رفع این کمبود، فرمتهای js انعطاف بیشتری در مقداردهی فراهم می‌آورند و من ترجیح می‌دهم تا آنجایی که ممکن از از فایل‌های js استفاده کنم. این قاعده در تمام موارد بالا رعایت شده است و بجای فایلهای json از js استفاده شده است.
